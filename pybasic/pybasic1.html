<h1>some key points in python</h1>
<h2>print</h2>
<p>Print followed by multiple outputs, separated by commas<br />
<code>a=1</code><br />
<code>print(a,type(a))</code></p>
<h2>sequence</h2>
<p>There are two kinds of sequences: tuple and list.</p>
<pre><code>s1=(2,1.3,'love')
s2=[True,5,'smile']
print(s1,type(s1))
print(s2,type(s2))
</code></pre>

<h2>Index of elements</h2>
<p>Subscripts for sequence elements start at 0<br />
<code>print(s1[0])</code><br />
Basic Style [Lower Limit: Upper Limit: Step Size]<br />
<code>print(s1[2:0:-1])</code><br />
(The Upper limit itself is not included.)</p>
<h2>Strings are tuples</h2>
<h2>Operation</h2>
<p><code>print 'a' in ['a','b']</code></p>
<h2>Indent</h2>
<pre><code>a=2  
b=1  
if a&gt;b:
print a+b
else:
print a-b  
</code></pre>

<h2>Loop</h2>
<p>range()<br />
for element in sequence<br />
while conditon:<br />
continue<br />
break  </p>
<h2>Function Define</h2>
<pre><code>a=1
def change_integer(a):
    a +=1
    return a

print change_integer(a)
print a

#===
b =[1,2,3]

def change_list(b):
    b[0] +=1
    return b
print change_list(b)
print b

</code></pre>

<p>In the first example, we pass an integer variable to a function, which operates on it, but the original integer variable a does not change.
In the second example, we pass a table to a function, which operates, and the original table B changes.
For variables of basic data type, when variables are passed to the function, the function replicates a new variable in memory without affecting the original variable. (We call this value transfer)
But for a table, the table passes a pointer to the function, pointer points to the position of the sequence in memory, the operation of the table in the function will be carried out in the original memory, thus affecting the original variables. We call this pointer passing.</p>
<h2>Object-oriented programming</h2>
<p>Python uses class and object to perform object-oriented programming (OOP) programming.</p>
<pre><code>class Bird(object):
    have_feather= True
    way_of_reproduction = 'egg'
</code></pre>

<p>References to <em>attributes</em> are implemented as objects.attribute,like </p>
<pre><code>summer = Bird()
summer.way_of_reproduction
</code></pre>

<h2>Object-objects programming 2nd</h2>
<p><strong>init</strong>() is a special method,Python has some special methods. Python treats them specially. The special method is characterized by two underscores before and after the name 
If you define the <strong>init</strong>() method in your class, Python will automatically call this method when you create the object. This process is also called initialization.</p>
<pre><code>class happyBird(Bird):
   def __init__(self,more_words):
   print 'We are happy birds.',more_words 
   summer = happyBird('Happy,Happy!')
</code></pre>

<h2>dictionary</h2>
<p>The elements of the dictionary are not in order. You cannot reference an element by subscript. The dictionary is referenced by a key.</p>
<pre><code>dic = {'tom':11, 'sam':57,'lily':100}
print dic['sam']
</code></pre>

<h2>There are other ways to introduce in Python</h2>
<pre><code>import a as b
# import module a, and rename it as b
from a import function1 
# import function1 from module a, and it is not needed to explain the module when we use the objcet **function1**,**function1** is okay,not the**a.function1**.
from a import *
# import all the objects from module a.
</code></pre>

<h2>Search path</h2>
<ol>
<li pref="">the folder wherer the program is located</li>
<li pref="">standard library installation path</li>
<li pref="">path included in the operating system environment variable PYTHONPATH<br />
If you have a custom module, or a downloaded module, you can place it in the appropriate path so that Python can find it.</li>
</ol>
<pre><code>import this_dir.module 
# a *__init__.py* must be in the directory *this_dir*,*__init__* can be an empty file.
</code></pre>
